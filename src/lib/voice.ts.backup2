let playbackQueue: Promise<void> = Promise.resolve();
let currentAudio: HTMLAudioElement | null = null;
let isPlaying = false;

export interface ElevenLabsSettings {
  stability?: number;
  similarity_boost?: number;
  style?: number;
  use_speaker_boost?: boolean;
}

// Enhanced voice presets for more natural speech
const VOICE_PRESETS: Record<string, ElevenLabsSettings> = {
  // ElevenLabs stock IDs ‚Üí tuning presets
  '21m00Tcm4TlvDq8ikWAM': { stability: 0.28, similarity_boost: 0.96, style: 0.55, use_speaker_boost: true }, // Rachel
  'AZnzlk1XvdvUeBnXmlld': { stability: 0.30, similarity_boost: 0.97, style: 0.60, use_speaker_boost: true }, // Bella
  'EXAVITQu4vr4xnSDxMaL': { stability: 0.32, similarity_boost: 0.95, style: 0.52, use_speaker_boost: true }, // Sarah
  'TxGEqnHWrfWFTfGW9XjX': { stability: 0.27, similarity_boost: 0.95, style: 0.58, use_speaker_boost: true }, // Emily (en-GB)
  'ErXwobaYiN019PkySvjV': { stability: 0.30, similarity_boost: 0.95, style: 0.50, use_speaker_boost: true }, // Elli
  'pNInz6obpgDQGcFmaJgB': { stability: 0.25, similarity_boost: 0.96, style: 0.62, use_speaker_boost: true }, // Olivia
  'MF3mGyEYCl7XYWbV9V6O': { stability: 0.30, similarity_boost: 0.96, style: 0.57, use_speaker_boost: true }, // Cora
  'onwK4e9ZLuTAKqWW03F9': { stability: 0.26, similarity_boost: 0.95, style: 0.60, use_speaker_boost: true }, // Domi
};

function getPersistedTuning(voiceId?: string): ElevenLabsSettings | undefined {
  try {
    const raw = localStorage.getItem('loveai-voice-tuning');
    if (!raw) return undefined;
    const all = JSON.parse(raw) as Record<string, ElevenLabsSettings>;
    return voiceId && all[voiceId] ? all[voiceId] : all['__default'];
  } catch {
    return undefined;
  }
}

function mergeSettings(voiceId?: string, override?: ElevenLabsSettings): ElevenLabsSettings {
  const preset = (voiceId && VOICE_PRESETS[voiceId]) ? VOICE_PRESETS[voiceId] : undefined;
  const persisted = getPersistedTuning(voiceId);
  return {
    stability: override?.stability ?? persisted?.stability ?? preset?.stability ?? 0.30,
    similarity_boost: override?.similarity_boost ?? persisted?.similarity_boost ?? preset?.similarity_boost ?? 0.95,
    style: override?.style ?? persisted?.style ?? preset?.style ?? 0.55,
    use_speaker_boost: override?.use_speaker_boost ?? persisted?.use_speaker_boost ?? preset?.use_speaker_boost ?? true,
  };
}

export async function speakText(
  text: string,
  voiceId?: string,
  options?: { modelId?: string; voiceSettings?: ElevenLabsSettings }
): Promise<void> {
  console.log('üé§ Speaking text:', text.slice(0, 50) + '...', 'Voice ID:', voiceId);
  
  const task = async () => {
    try {
      // Stop any current audio
      stopAllTTS();
      
      // Resolve best-available settings
      const settings = mergeSettings(voiceId, options?.voiceSettings);
      console.log('üîß Voice settings:', settings);

      // Try multiple API endpoints for reliability
      const endpoints = [
        '/api/elevenlabs-tts',
        '/.netlify/functions/elevenlabs-tts'
      ];

      let response: Response | null = null;
      let lastError: Error | null = null;

      for (const endpoint of endpoints) {
        try {
          console.log('üåê Trying endpoint:', endpoint);
          
          response = await fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
              text, 
              voice_id: voiceId || '21m00Tcm4TlvDq8ikWAM',
              model_id: options?.modelId || 'eleven_multilingual_v2',
              voice_settings: settings
            }),
            signal: AbortSignal.timeout(20000) // Increased timeout
          });

          if (response.ok) {
            console.log('‚úÖ Success with endpoint:', endpoint);
            break;
          } else {
            const errorText = await response.text();
            console.warn('‚ö†Ô∏è Endpoint failed:', endpoint, response.status, errorText);
            lastError = new Error(`Endpoint ${endpoint} failed: ${response.status} - ${errorText}`);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è Endpoint error:', endpoint, error);
          lastError = error as Error;
        }
      }

      if (!response || !response.ok) {
        throw lastError || new Error('All TTS endpoints failed');
      }

      const blob = await response.blob();
      console.log('üì¶ Received audio blob:', blob.size, 'bytes');
      
      if (blob.size === 0) {
        throw new Error('Empty audio response');
      }

      const url = URL.createObjectURL(blob);
      try {
        await playAudio(url);
        console.log('üîä Audio playback completed');
      } finally {
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('‚ùå TTS Error:', error);
      
      // Fallback to browser TTS if ElevenLabs fails
      console.log('üîÑ Falling back to browser TTS');
      await fallbackTTS(text);
    }
  };

  playbackQueue = playbackQueue.then(task).catch(async (e) => { 
    console.error('‚ùå Playback queue error:', e);
    throw e; 
  });
  return playbackQueue;
}

// Fallback to browser TTS
async function fallbackTTS(text: string): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.9;
      utterance.pitch = 1.1;
      utterance.volume = 1.0;
      
      // Try to find a female voice
      const voices = speechSynthesis.getVoices();
      const femaleVoice = voices.find(voice => 
        voice.name.toLowerCase().includes('female') || 
        voice.name.toLowerCase().includes('woman') ||
        voice.name.toLowerCase().includes('zira') ||
        voice.name.toLowerCase().includes('susan')
      );
      
      if (femaleVoice) {
        utterance.voice = femaleVoice;
      }
      
      utterance.onend = () => {
        console.log('üîä Fallback TTS completed');
        resolve();
      };
      
      utterance.onerror = (event) => {
        console.error('‚ùå Fallback TTS error:', event.error);
        reject(new Error(`Fallback TTS failed: ${event.error}`));
      };
      
      speechSynthesis.speak(utterance);
    } catch (error) {
      console.error('‚ùå Fallback TTS setup error:', error);
      reject(error);
    }
  });
}

export function stopAllTTS(): void {
  console.log('üõë Stopping all TTS');
  isPlaying = false;
  
  try { 
    speechSynthesis.cancel(); 
  } catch (error) {
    console.warn('‚ö†Ô∏è Error canceling speech synthesis:', error);
  }
  
  try {
    if (currentAudio) {
      currentAudio.pause();
      currentAudio.currentTime = 0;
      currentAudio = null;
    }
  } catch (error) {
    console.warn('‚ö†Ô∏è Error stopping audio:', error);
  }
}

function playAudio(url: string): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      // Stop any previous audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
      }
      
      const audio = new Audio(url);
      currentAudio = audio;
      isPlaying = true;
      
      const onEnded = () => {
        console.log('üîä Audio playback ended');
        cleanup();
        isPlaying = false;
        resolve();
      };
      
      const onError = (event: any) => {
        console.error('‚ùå Audio playback error:', event);
        cleanup();
        isPlaying = false;
        reject(new Error('Audio playback failed'));
      };
      
      const onLoadStart = () => {
        console.log('üîÑ Audio loading started');
      };
      
      const onCanPlay = () => {
        console.log('‚úÖ Audio ready to play');
      };
      
      const cleanup = () => {
        audio.removeEventListener('ended', onEnded);
        audio.removeEventListener('error', onError);
        audio.removeEventListener('loadstart', onLoadStart);
        audio.removeEventListener('canplay', onCanPlay);
        if (currentAudio === audio) {
          currentAudio = null;
          isPlaying = false;
        }
      };
      
      audio.addEventListener('ended', onEnded);
      audio.addEventListener('error', onError);
      audio.addEventListener('loadstart', onLoadStart);
      audio.addEventListener('canplay', onCanPlay);
      
      // Set audio properties for better quality
      audio.volume = 1.0;
      audio.preload = 'auto';
      
      console.log('üéµ Starting audio playback');
      audio.play().catch((error) => {
        console.error('‚ùå Audio play failed:', error);
        cleanup();
        isPlaying = false;
        reject(error);
      });
    } catch (error) {
      console.error('‚ùå Audio setup error:', error);
      isPlaying = false;
      reject(error);
    }
  });
}

// Check if TTS is currently playing
export function isTTSPlaying(): boolean {
  return isPlaying;
}

// Get available voices
export function getAvailableVoices(): SpeechSynthesisVoice[] {
  return speechSynthesis.getVoices();
}

// Test voice functionality
export async function testVoice(voiceId?: string): Promise<boolean> {
  try {
    await speakText("Hello! This is a voice test.", voiceId);
    return true;
  } catch (error) {
    console.error('Voice test failed:', error);
    return false;
  }
}
